return (function()
    local ESP = {}

    function ESP:AddESP(object, options)
        if not object or (not object:IsA("BasePart") and not object:IsA("Model")) then
            return
        end

        local espLabel = Instance.new("BillboardGui")
        espLabel.Adornee = object.PrimaryPart or object:FindFirstChildOfClass("BasePart")
        espLabel.Size = UDim2.new(0, 100, 0, 50)
        espLabel.StudsOffset = Vector3.new(0, 3, 0)

        local espText = Instance.new("TextLabel", espLabel)
        espText.Size = UDim2.new(1, 0, 1, 0)
        espText.BackgroundTransparency = 1
        espText.TextColor3 = options.Color or Color3.fromRGB(255, 0, 0)
        espText.TextStrokeTransparency = 0.5
        espText.TextScaled = true

        local highlight = Instance.new("Highlight")
        highlight.Adornee = object
        highlight.FillColor = options.HighlightColor or Color3.fromRGB(1, 1, 1)
        highlight.OutlineColor = options.OutlineColor or Color3.fromRGB(1, 0, 0)
        highlight.OutlineTransparency = 0.5
        highlight.Parent = object

        local function updateESP()
            if object and (object:IsA("BasePart") or object:IsA("Model")) then
                espLabel.Adornee = object.PrimaryPart or object:FindFirstChildOfClass("BasePart")

                local playerPosition = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character.PrimaryPart.Position
                if playerPosition then
                    local distance = (espLabel.Adornee.Position - playerPosition).magnitude
                    
                    local attributeValue = options.Attribute and object:GetAttribute(options.Attribute) or "N/A"
                    
                    espText.Text = string.format("%s\nDistance: %.1f\n%s: %s", options.CustomName or "Object", distance, options.Attribute or "Attribute", attributeValue)
                else
                    espText.Text = options.CustomName or "Object"
                end
            else
                highlight:Destroy()
                espLabel:Destroy()
            end
        end

        espLabel.Parent = espLabel.Adornee

        game:GetService("RunService").RenderStepped:Connect(updateESP)
    end

    function ESP:SetupESPForPlayer(player, options)
        player.CharacterAdded:Connect(function()
            self:AddESP(player.Character.PrimaryPart, options)
        end)

        if player.Character then
            self:AddESP(player.Character.PrimaryPart, options)
        end
    end

    function ESP:MonitorObject(object, options)
        self:AddESP(object, options)
    end

    function ESP:MonitorCurrentRoom(currentRoom, options)
        for _, child in ipairs(currentRoom:GetDescendants()) do
            if child:IsA("BasePart") or child:IsA("Model") then
                self:MonitorObject(child, options)
            end
        end
    end

    function ESP:MonitorAssets(assetFolder, options)
        for _, asset in ipairs(assetFolder:GetDescendants()) do
            if asset:IsA("BasePart") or asset:IsA("Model") then
                self:MonitorObject(asset, options)  -- 修正了这里的拼写错误
            end
        end
    end

    return ESP -- 返回模块
end)()

local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = getgenv().Linoria.Options
local Toggles = getgenv().Linoria.Toggles

local Window = Library:CreateWindow({
	-- Set Center to true if you want the menu to appear in the center
	-- Set AutoShow to true if you want the menu to appear when it is created
	-- Set Resizable to true if you want to have in-game resizable Window
	-- Set ShowCustomCursor to false if you don't want to use the Linoria cursor
	-- Position and Size are also valid options here
	-- but you do not need to define them unless you are changing them :)

	Title = 'Expliot Doors v1',
	Center = true,
	AutoShow = true,
	Resizable = true,
	ShowCustomCursor = true,
	TabPadding = 8,
	MenuFadeTime = 0.2
})

-- CALLBACK NOTE:
-- Passing in callback functions via the initial element parameters (i.e. Callback = function(Value)...) works
-- HOWEVER, using Toggles/Options.INDEX:OnChanged(function(Value) ... ) is the RECOMMENDED way to do this.
-- I strongly recommend decoupling UI code from logic code. i.e. Create your UI elements FIRST, and THEN setup :OnChanged functions later.

-- You do not have to set your tabs & groups up this way, just a prefrence.
local Tabs = {
	-- Creates a new tab titled Main
	Main = Window:AddTab('LocalPlayer'),
	['UI Settings'] = Window:AddTab('UI Settings'),
}


local TabBox = Tabs.Main:AddLeftTabbox() -- Add Tabbox on left side

local Tab1 = TabBox:AddTab('Speed')
local Tab2 = TabBox:AddTab('Camera')

local RunService = game:GetService("RunService")
local Camera = game:GetService("Workspace").CurrentCamera

LeftGroupBox:AddDropdown('SpeedModeDropdown', {
    Values = { 'WalkSpeed', 'CFrame' },
    Default = 1,
    Multi = false,
    Text = 'Speed Mode',
})

Tab1:AddSlider('MySlider', {
    Text = 'Speed',
    Default = 0,
    Min = 0,
    Max = 5,
    Rounding = 1
})

Tab2:AddSlider('FOVSlider', {
    Text = 'Field of View',
    Default = 70,
    Min = 0,
    Max = 120,
    Rounding = 1
})

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local originalWalkSpeed = humanoid.WalkSpeed
local lastPosition = character.HumanoidRootPart.Position

local function updateSpeed()
    local sliderValue = Options.MySlider.Value
    local speedMode = Options.SpeedModeDropdown.Value

    if speedMode == 'WalkSpeed' then
        humanoid.WalkSpeed = originalWalkSpeed + sliderValue
    elseif speedMode == 'CFrame' then
        local currentPosition = character.HumanoidRootPart.Position
        local distanceMoved = (currentPosition - lastPosition).magnitude

        if distanceMoved > 0 then
            local direction = character.HumanoidRootPart.CFrame.LookVector
            character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame + direction * sliderValue
        end

        lastPosition = currentPosition
    end
end

local function updateFOV()
    Camera.FieldOfView = Options.FOVSlider.Value
end

RunService.RenderStepped:Connect(function()
    updateSpeed()
    updateFOV()
end)

Options.MySlider:OnChanged(function()
    updateSpeed()
end)

Options.SpeedModeDropdown:OnChanged(function()
    updateSpeed()
end)

Options.FOVSlider:OnChanged(function()
    updateFOV()
end)

Library:SetWatermarkVisibility(true)

-- Example of dynamically-updating watermark with common traits (fps and ping)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
	FrameCounter += 1;

	if (tick() - FrameTimer) >= 1 then
		FPS = FrameCounter;
		FrameTimer = tick();
		FrameCounter = 0;
	end;

	Library:SetWatermark(('LinoriaLib demo | %s fps | %s ms'):format(
		math.floor(FPS),
		math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
	));
end);

Library.KeybindFrame.Visible = true; -- todo: add a function for this

Library:OnUnload(function()
	WatermarkConnection:Disconnect()

	print('Unloaded!')
	Library.Unloaded = true
end)

-- UI Settings
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

-- I set NoUI so it does not show up in the keybinds menu
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- ThemeManager (Allows you to have a menu theme system)

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
-- (do you want each config to have a different menu key? probably not.)
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])

-- Builds our theme menu (with plenty of built in themes) on the left side
-- NOTE: you can also call ThemeManager:ApplyToGroupbox to add it to a specific groupbox
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
