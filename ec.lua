local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = getgenv().Linoria.Options
local Toggles = getgenv().Linoria.Toggles

local Window = Library:CreateWindow({
	-- Set Center to true if you want the menu to appear in the center
	-- Set AutoShow to true if you want the menu to appear when it is created
	-- Set Resizable to true if you want to have in-game resizable Window
	-- Set ShowCustomCursor to false if you don't want to use the Linoria cursor
	-- Position and Size are also valid options here
	-- but you do not need to define them unless you are changing them :)

	Title = 'Expliot Doors v1',
	Center = true,
	AutoShow = true,
	Resizable = true,
	ShowCustomCursor = true,
	TabPadding = 8,
	MenuFadeTime = 0.2
})

-- CALLBACK NOTE:
-- Passing in callback functions via the initial element parameters (i.e. Callback = function(Value)...) works
-- HOWEVER, using Toggles/Options.INDEX:OnChanged(function(Value) ... ) is the RECOMMENDED way to do this.
-- I strongly recommend decoupling UI code from logic code. i.e. Create your UI elements FIRST, and THEN setup :OnChanged functions later.

-- You do not have to set your tabs & groups up this way, just a prefrence.
local Tabs = {
	-- Creates a new tab titled Main
	Main = Window:AddTab('LocalPlayer'),
	['UI Settings'] = Window:AddTab('UI Settings'),
}


local TabBox = Tabs.Main:AddLeftTabbox() -- Add Tabbox on left side

local Tab1 = TabBox:AddTab('Speed')
local Tab2 = TabBox:AddTab('Camera')

local RunService = game:GetService("RunService")
local Camera = game:GetService("Workspace").CurrentCamera

Tab1:AddDropdown('SpeedModeDropdown', {
    Values = { 'WalkSpeed', 'CFrame' },
    Default = 1,
    Multi = false,
    Text = 'Speed Mode',
})

Tab1:AddSlider('MySlider', {
    Text = 'Speed',
    Default = 0,
    Min = 0,
    Max = 5,
    Rounding = 1
})

Tab2:AddSlider('FOVSlider', {
    Text = 'Field of View',
    Default = 70,
    Min = 0,
    Max = 120,
    Rounding = 1
})

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local originalWalkSpeed = humanoid.WalkSpeed
local lastPosition = character.HumanoidRootPart.Position

local function updateSpeed()
    local sliderValue = Options.MySlider.Value
    local speedMode = Options.SpeedModeDropdown.Value

    if speedMode == 'WalkSpeed' then
        humanoid.WalkSpeed = originalWalkSpeed + sliderValue
    elseif speedMode == 'CFrame' then
        local currentPosition = character.HumanoidRootPart.Position
        local distanceMoved = (currentPosition - lastPosition).magnitude

        if distanceMoved > 0 then
            local direction = character.HumanoidRootPart.CFrame.LookVector
            character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame + direction * sliderValue
        end

        lastPosition = currentPosition
    end
end

local function updateFOV()
    Camera.FieldOfView = Options.FOVSlider.Value
end

RunService.RenderStepped:Connect(function()
    updateSpeed()
    updateFOV()
end)

Options.MySlider:OnChanged(function()
    updateSpeed()
end)

Options.SpeedModeDropdown:OnChanged(function()
    updateSpeed()
end)

Options.FOVSlider:OnChanged(function()
    updateFOV()
end)

Library:SetWatermarkVisibility(true)
local speedBypassing = false
local collisionClone
local character = --[[ 获取你的角色对象 ]]
local Options = {
    SpeedBypassMethod = { Value = "Massless" },
    SpeedBypassDelay = { Value = 0.1 }  -- 调整延迟
}

-- 速度绕过功能
function Script.Functions.SpeedBypass()
    if speedBypassing then return end
    speedBypassing = true

    local SpeedBypassMethod = Options.SpeedBypassMethod.Value

    local function cleanup()
        speedBypassing = false
        if collisionClone then
            if SpeedBypassMethod == "Massless" then
                collisionClone.Massless = true
            elseif SpeedBypassMethod == "Size" then
                collisionClone.Size = Vector3.new(3, 5.5, 3)
            end
        end
    end

    task.spawn(function()
        if SpeedBypassMethod == "Massless" then
            while Toggles.SpeedBypass.Value and collisionClone and Options.SpeedBypassMethod.Value == SpeedBypassMethod do
                collisionClone.Massless = not collisionClone.Massless
                task.wait(Options.SpeedBypassDelay.Value)
            end
            cleanup()
        elseif SpeedBypassMethod == "Size" then
            while Toggles.SpeedBypass.Value and collisionClone and Options.SpeedBypassMethod.Value == SpeedBypassMethod do
                collisionClone.Size = Vector3.new(3, 5.5, 3)
                task.wait(Options.SpeedBypassDelay.Value)
                collisionClone.Size = Vector3.new(1.5, 2.75, 1.5)
                task.wait(Options.SpeedBypassDelay.Value)
            end
            cleanup()
        end
    end)
end

-- Tab1 中的切换按钮
Tab1:AddToggle('Tab', { Text = 'Tab1 Toggle' });

Toggles.Tab:OnChanged(function(state)
    Toggles.SpeedBypass.Value = state  -- 更新 SpeedBypass 的状态

    if state then
        Script.Functions.SpeedBypass()
    else
        speedBypassing = false
        if collisionClone then
            collisionClone.Massless = false  -- 恢复碰撞属性
        end
    end
end)

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local camera = workspace.CurrentCamera

local Toggles = {
    ThirdPersonToggle = { Value = false, OnChanged = function() end }
}

-- 隐藏角色的头部
local function hideHead()
    local head = character:FindFirstChild("Head")
    if head then
        head.Transparency = 0  -- 使头部透明
        head.CanCollide = true  -- 禁止碰撞
    end
end

-- 设置摄像机为固定的第三人称视角
local function setCamera()
    local distance = 10
    local offset = Vector3.new(0, 2, distance)  -- 头部上方2个单位，后方10个单位

    while Toggles.ThirdPersonToggle.Value do
        if character and character:FindFirstChild("HumanoidRootPart") then
            local rootPart = character.HumanoidRootPart

            -- 设置摄像机位置和方向
            camera.CFrame = CFrame.new(rootPart.Position + offset, rootPart.Position)
        end
        
        wait(0.03)  -- 调整更新频率
    end
end

-- 切换按钮事件
Toggles.ThirdPersonToggle.OnChanged = function()
    if Toggles.ThirdPersonToggle.Value then
        hideHead()  -- 隐藏头部
        setCamera()  -- 启动摄像机设置
    else
        -- 如果切换到关闭状态，可以在这里恢复头部的可见性
        local head = character:FindFirstChild("Head")
        if head then
            head.Transparency = 0  -- 恢复头部的可见性
            head.CanCollide = true  -- 恢复碰撞
        end
    end
end

-- 假设你在某个地方添加了切换按钮
Tab2:AddToggle('ThirdPersonToggle', { Text = '3D View' }, function(state)
    Toggles.ThirdPersonToggle.Value = state  -- 更新切换值
    Toggles.ThirdPersonToggle.OnChanged()  -- 调用事件
end)

-- Example of dynamically-updating watermark with common traits (fps and ping)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
	FrameCounter += 1;

	if (tick() - FrameTimer) >= 1 then
		FPS = FrameCounter;
		FrameTimer = tick();
		FrameCounter = 0;
	end;

	Library:SetWatermark(('Expliot| %s fps | %s ms'):format(
		math.floor(FPS),
		math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
	));
end);

Library.KeybindFrame.Visible = true; -- todo: add a function for this

Library:OnUnload(function()
	WatermarkConnection:Disconnect()

	print('Unloaded!')
	Library.Unloaded = true
end)

-- UI Settings
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

-- I set NoUI so it does not show up in the keybinds menu
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- ThemeManager (Allows you to have a menu theme system)

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
-- (do you want each config to have a different menu key? probably not.)
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])

-- Builds our theme menu (with plenty of built in themes) on the left side
-- NOTE: you can also call ThemeManager:ApplyToGroupbox to add it to a specific groupbox
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
