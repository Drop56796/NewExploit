local flags = {
        sc = false,
	sj = false,
	sd = false,
	gc =false,
	g = false,
	g2 = false,
	error = false,
	r3 = false,
	eyes = false
}
local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = getgenv().Linoria.Options
local Toggles = getgenv().Linoria.Toggles
local textChannel = game:GetService("TextChatService"):WaitForChild("TextChannels"):WaitForChild("RBXGeneral")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local entityModules = ReplicatedStorage:WaitForChild("ClientModules"):WaitForChild("EntityModules")
local gameData = ReplicatedStorage:WaitForChild("GameData")
local floor = gameData:WaitForChild("Floor")
local latestRoom = gameData:WaitForChild("LatestRoom")
local remotesFolder = ReplicatedStorage:WaitForChild("RemotesFolder")
local Window = Library:CreateWindow({
	-- Set Center to true if you want the menu to appear in the center
	-- Set AutoShow to true if you want the menu to appear when it is created
	-- Set Resizable to true if you want to have in-game resizable Window
	-- Set ShowCustomCursor to false if you don't want to use the Linoria cursor
	-- Position and Size are also valid options here
	-- but you do not need to define them unless you are changing them :)

	Title = 'Expliot Doors v1',
	Center = true,
	AutoShow = true,
	Resizable = true,
	ShowCustomCursor = true,
	TabPadding = 8,
	MenuFadeTime = 0.2
})

-- CALLBACK NOTE:
-- Passing in callback functions via the initial element parameters (i.e. Callback = function(Value)...) works
-- HOWEVER, using Toggles/Options.INDEX:OnChanged(function(Value) ... ) is the RECOMMENDED way to do this.
-- I strongly recommend decoupling UI code from logic code. i.e. Create your UI elements FIRST, and THEN setup :OnChanged functions later.

-- You do not have to set your tabs & groups up this way, just a prefrence.
local Tabs = {
	-- Creates a new tab titled Main
	Main = Window:AddTab('LocalPlayer'),
	Main2 = Window:AddTab('Expliots'),
	['UI Settings'] = Window:AddTab('UI Settings'),
}
local SoundService = game:GetService("SoundService")

-- 添加并播放声音
local function addAndPlaySound(name, soundId)
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://" .. soundId
    sound.Name = name
    sound.Parent = SoundService
    sound:Play()
end
local RightGroup1 = Tabs.Main:AddLeftGroupbox('Nofiction')

RightGroup1:AddToggle('entityEvent', {
    Text = 'Entity Event',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(state)
        if state then
            local entityNames = {"RushMoving", "AmbushMoving", "Snare", "A60", "A120", "A90", "Eyes", "JeffTheKiller"} -- Entity names

            -- Ensure flags and plr are defined
            local flags = flags or {} -- Prevent errors
            local plr = game.Players.LocalPlayer -- Prevent errors

            local function notifyEntitySpawn(entity)
                local entityName = entity.Name:gsub("Moving", ""):lower()
                local entityMessage = entityName .. " " .. (customEntityMessage or "Spawned!")
                addAndPlaySound("ExampleSound", 4590657391)
                Library:Notify(entityMessage)
            end

            local function onChildAdded(child)
                if table.find(entityNames, child.Name) then
                    repeat
                        task.wait()
                    until plr:DistanceFromCharacter(child:GetPivot().Position) < 1000 or not child:IsDescendantOf(workspace)
                    
                    if child:IsDescendantOf(workspace) then
                        notifyEntitySpawn(child)
                    end
                end
            end

            -- Infinite loop to keep the script running and check the hintrush flag
            local running = true
            while running do
                local connection = workspace.ChildAdded:Connect(onChildAdded)
                
                repeat
                    task.wait(1) -- Adjust wait time as needed
                until not flags.hintrush or not running
                
                connection:Disconnect()
            end 
        else 
            -- Turn off notifications or perform other cleanup if needed
            running = false
        end
    end
})
RightGroup1:AddInput('EntityEventTextbox', {
    Default = 'Enity Event',
    Numeric = false, -- Allows both text and numbers
    Finished = false, -- Callback is called on every change, not just on pressing enter
    ClearTextOnFocus = true, -- Clears the text when the textbox is focused
    Text = '!',
    Tooltip = 'Enter a custom message for entity events', -- Tooltip shown on hover
    Placeholder = 'e.g., is approaching!', -- Example placeholder text
    Callback = function(Value)
        customEntityMessage = Value
        print('[cb] Custom entity event message updated:', customEntityMessage)
    end
})

local MiscGroupBox = Tabs.Main:AddRightGroupbox("Misc") do
    MiscGroupBox:AddButton({
        Text = "Revive <Need Robux>",
        Func = function()
            remotesFolder.Revive:FireServer()
        end,
        DoubleClick = true
    })

    MiscGroupBox:AddButton({
        Text = "Play Again",
        Func = function()
            remotesFolder.PlayAgain:FireServer()
        end,
        DoubleClick = true
    })

    MiscGroupBox:AddButton({
        Text = "Lobby",
        Func = function()
            remotesFolder.Lobby:FireServer()
        end,
        DoubleClick = true
    })
end
local TabBox = Tabs.Main:AddLeftTabbox() -- Add Tabbox on left side

local Tab1 = TabBox:AddTab('Speed')
local Tab2 = TabBox:AddTab('Camera')

local RunService = game:GetService("RunService")
local Camera = game:GetService("Workspace").CurrentCamera

Tab1:AddDropdown('SpeedModeDropdown', {
    Values = { 'WalkSpeed', 'CFrame' },
    Default = 1,
    Multi = false,
    Text = 'Speed Mode',
})

Tab1:AddSlider('MySlider', {
    Text = 'Speed',
    Default = 0,
    Min = 0,
    Max = 8,
    Rounding = 1
})

Tab2:AddSlider('FOVSlider', {
    Text = 'Field of View',
    Default = 70,
    Min = 0,
    Max = 120,
    Rounding = 1
})

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local originalWalkSpeed = humanoid.WalkSpeed
local lastPosition = character.HumanoidRootPart.Position

local function updateSpeed()
    local sliderValue = Options.MySlider.Value
    local speedMode = Options.SpeedModeDropdown.Value

    if speedMode == 'WalkSpeed' then
        humanoid.WalkSpeed = originalWalkSpeed + sliderValue
    elseif speedMode == 'CFrame' then
        local currentPosition = character.HumanoidRootPart.Position
        local distanceMoved = (currentPosition - lastPosition).magnitude

        if distanceMoved > 0 then
            local direction = character.HumanoidRootPart.CFrame.LookVector
            character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame + direction * sliderValue
        end

        lastPosition = currentPosition
    end
end

local function updateFOV()
    Camera.FieldOfView = Options.FOVSlider.Value
end

RunService.RenderStepped:Connect(function()
    updateSpeed()
    updateFOV()
end)

Options.MySlider:OnChanged(function()
    updateSpeed()
end)

Options.SpeedModeDropdown:OnChanged(function()
    updateSpeed()
end)

Options.FOVSlider:OnChanged(function()
    updateFOV()
end)

Library:SetWatermarkVisibility(true)

-- Tab1 中的切换按钮
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local collision = character:WaitForChild("Collision")
local collisionClone

if collision then
    collisionClone = collision:Clone()
    collisionClone.CanCollide = false
    collisionClone.Massless = true
    collisionClone.Name = "CollisionClone"
    
    if collisionClone:FindFirstChild("CollisionCrouch") then
        collisionClone.CollisionCrouch:Destroy()
    end

    collisionClone.Parent = character
end

-- Speed Bypass Toggle
Tab1:AddToggle('SpeedBypass', { Text = 'Speed Bypass' });

Toggles.SpeedBypass:OnChanged(function(value)
    if value then
        while Toggles.SpeedBypass.Value and collisionClone do
            collisionClone.Massless = not collisionClone.Massless
            task.wait(0.225)
        end
    else
        if collisionClone then 
            collisionClone.Massless = true 
        end
    end
end)
local MainGroup3 = Tabs.Main2:AddLeftGroupbox('Enity (F1)')
local FTGroup = Tabs.Main2:AddRightGroupbox('Enity (F2)')
MainGroup3:AddToggle('No Clip', {
    Text = 'Expilot Spider jumpscare',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(state)
        flags.sj = state -- 鏇存柊 flag 涓哄綋鍓� state
        
        if flags.sj then
            local sj = game.ReplicatedStorage.RemotesFolder:FindFirstChild("SpiderJumpscare")
            if sj then
                -- 褰� noa90 涓� true 涓� A90 瀛樺湪鏃讹紝鍒犻櫎 A90
                sj:Destroy()
            end
        end
    end
})
MainGroup3:AddToggle('No Clip', {
    Text = 'Expilot Eyes',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(state)
        flags.eyes = state -- 更新 flag 为当前 state
        
        while flags.eyes do
            local eyes = game.Workspace:FindFirstChild("Eyes")
            if eyes then
                remotesFolder.MotorReplication:FireServer(-650)
            end
            wait(0.001) -- 等待一秒后再次检查
        end
    end
})
MainGroup3:AddToggle('AntiHalt', {
    Text = 'Expilot halt',
    Default = false,
    Tooltip = 'Walk through walls',
})
Toggles.AntiHalt:OnChanged(function(value)
    if not entityModules then return end
    local module = entityModules:FindFirstChild("Shade") or entityModules:FindFirstChild("_Shade")

    if module then
        module.Name = value and "_Shade" or "Shade"
    end
end)

MainGroup3:AddToggle('No Clip', {
    Text = 'Expilot Screech',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(state)
        flags.sc = state -- 鏇存柊 flag 涓哄綋鍓� state
        
        if flags.sc then
            local entities = game.ReplicatedStorage.Entities
            local remotes = game.ReplicatedStorage.RemotesFolder
            
            local targets = {
                remotes:FindFirstChild("Screech"),
                entities:FindFirstChild("ScreechRetro"),
                entities:FindFirstChild("Screech")
            }
            
            for _, target in ipairs(targets) do
                if target then
                    target:Destroy()
                end
            end
        end
    end
})
MainGroup3:AddToggle('No Clip', {
    Text = 'Expilot Snare',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(state)
        flags.sd = state -- 鏇存柊 flag 涓哄綋鍓� state
        
        while flags.sd do
            local currentRooms = game.Workspace:FindFirstChild("CurrentRooms")
            if currentRooms then
                for _, room in ipairs(currentRooms:GetChildren()) do
                    local assets = room:FindFirstChild("Assets")
                    if assets then
                        local snare = assets:FindFirstChild("Snare")
                        if snare then
                            snare:Destroy()
                        end
                    end
                end
            end
            wait(0.1) -- 绛夊緟涓€绉掑悗鍐嶆妫€鏌�
        end
    end
})
MainGroup3:AddToggle('pe', {
    Text = 'Expilot Seek Arm / Fire',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(v)
	flags.r3 = v
	
        if v then
            game:GetService("RunService").RenderStepped:Connect(function()
                pcall(function()
                    if flags.r3 then
                        local latestRoom = game:GetService("ReplicatedStorage").GameData.LatestRoom.Value
                        local currentRoom = game.workspace.CurrentRooms[tostring(latestRoom)]
                        local assets = currentRoom:WaitForChild("Assets")

                        -- 閿€姣� ChandelierObstruction 鍜� Seek_Arm
                        if assets:FindFirstChild("ChandelierObstruction") then
                            assets.ChandelierObstruction:Destroy()
                        end

                        for i = 1, 15 do
                            if assets:FindFirstChild("Seek_Arm") then
                                assets.Seek_Arm:Destroy()
                            end
                        end
                    end
                end)
            end)
        end
    end
})

destroy = "Remove Event:Destroy giggle now"
destroy1 = "Remove Event:Destroy GloomPile now"
destroy2 = "Remove Event:Destroy Bat now"
FTGroup:AddToggle('No Clip', {
        Text = 'Expilot GiggleCeiling',
        Default = false,
        Tooltip = 'Remove GiggleCeiling from rooms',
        Callback = function(state)
            flags.gc = state

            while flags.giggleCeiling do
                local currentRooms = game.Workspace:FindFirstChild("CurrentRooms")
                if currentRooms then
                    for _, room in ipairs(currentRooms:GetChildren()) do
                        local giggleCeiling = room:FindFirstChild("GiggleCeiling")
                        if giggleCeiling then
                            giggleCeiling:Destroy()
			    Library:Notify(destroy)
                        end
                    end
                end
                wait(0.1)
            end
        end
    })

    FTGroup:AddToggle('No Clip', {
        Text = 'Expilot GloomPile',
        Default = false,
        Tooltip = 'Remove GloomPile from rooms',
        Callback = function(state)
            flags.g = state

            while flags.g do
                local currentRooms = game.Workspace:FindFirstChild("CurrentRooms")
                if currentRooms then
                    for _, room in ipairs(currentRooms:GetChildren()) do
                        local gloomPile = room:FindFirstChild("GloomPile")
                        if gloomPile then
                            gloomPile:Destroy()
			    Library:Notify(destroy1)
                        end
                    end
                end
                wait(0.1)
            end
        end
    })

    FTGroup:AddToggle('No Clip', {
        Text = 'Expilot bat',
        Default = false,
        Tooltip = 'Remove GloombatSwarm from rooms',
        Callback = function(state)
            flags.g2 = state

            while flags.g2 do
                local spawned = game.Workspace:FindFirstChild("GloombatSwarm")
                if spawned then
                    spawned:Destroy()
		    Library:Notify(destroy2)
                end
                wait(0.1)
            end
        end
    })

MainGroup3:AddToggle('No Clip', {
    Text = 'Expilot A90',
    Default = false,
    Tooltip = 'Walk through walls',
    Callback = function(state)
        flags.error = state -- 鏇存柊 flag 涓哄綋鍓� state
        
        if flags.error then
            if LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener.Modules:FindFirstChild("A90") then
                LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener.Modules.A90.Name = "lol"
	    end
        end
    end
})
-- Example of dynamically-updating watermark with common traits (fps and ping)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
	FrameCounter += 1;

	if (tick() - FrameTimer) >= 1 then
		FPS = FrameCounter;
		FrameTimer = tick();
		FrameCounter = 0;
	end;

	Library:SetWatermark(('Expliot| %s fps | %s ms'):format(
		math.floor(FPS),
		math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
	));
end);
        

-- Example usage
-- Update the watermark (this can be called periodically in a loop if needed)
updateWatermark(FPS, currentRoom)

Library.KeybindFrame.Visible = true; -- todo: add a function for this

Library:OnUnload(function()
	WatermarkConnection:Disconnect()

	print('Unloaded!')
	Library.Unloaded = true
end)

-- UI Settings
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

-- I set NoUI so it does not show up in the keybinds menu
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- ThemeManager (Allows you to have a menu theme system)

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
-- (do you want each config to have a different menu key? probably not.)
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])

-- Builds our theme menu (with plenty of built in themes) on the left side
-- NOTE: you can also call ThemeManager:ApplyToGroupbox to add it to a specific groupbox
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
